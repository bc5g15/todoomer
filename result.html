<html>
    <style>
        .leaf {
            outline: 1px solid black;
            background-color: white;
            padding-inline: 1em;
        }
        .branch {
            padding: 1em;
            margin: 1em;
            outline: 1px solid green;
            background-color: aqua;
            min-height: 5em;
            height: fit-content
        }
        .root {
            display: flex;
        }
        .dynamicText {
            margin-block-start: 1em;
            margin-block-end: 1em;
            display:block;
        }
        .dropZonePotential { 
            background-color: blue;
        }
        .dropZoneSelected {
            background-color: green;
        }
    </style>
    <head>
        <title>Todoomer</title>
    </head>
    <body></body>
    <script>
        const promiseText = (defaultString = "") => {
  const magicForm = document.createElement("form");
  const textInput = document.createElement("input");
  textInput.className = "dynamicText";
  magicForm.append(textInput);
  textInput.value = defaultString;
  const p = new Promise((res) => {
    const submit = () => {
      const textResult = textInput.value;
      res(textResult);
    };
    magicForm.onsubmit = submit;
    textInput.onblur = submit;
  });
  return [magicForm, p, () => textInput.focus()];
};
const promiseTextButton = (handleText) => {
  const btn = document.createElement("button");
  btn.textContent = "+";
  btn.onclick = async () => {
    const [form, promise, focus] = promiseText();
    btn.replaceWith(form);
    focus();
    const result = await promise;
    handleText(result);
    form.replaceWith(btn);
  };
  return btn;
};
const promiseTextDisplay = (textValue, handleText) => {
  const para = document.createElement("p");
  para.innerText = textValue;
  para.className = "editableText";
  para.onclick = async () => {
    const [form, promise, focus] = await promiseText();
    para.replaceWith(form);
    focus();
    const result = await promise;
    handleText(result);
    para.innerText = result;
    form.replaceWith(para);
  };
  return para;
};
const findByIndex = (lst, index) => {
  let r = lst.next;
  if (!r)
    return;
  while (index > 0) {
    index--;
    if (!r?.next)
      return;
    r = r.next;
  }
  return r.value;
};
const removeAt = (lst, index) => {
  let r = lst;
  while (index > 0) {
    index--;
    if (!r.next)
      return;
    r = r.next;
  }
  r.next = r.next?.next ?? undefined;
};
const insertAt = (lst, index, item) => {
  let r = lst;
  while (index > 0) {
    index--;
    if (!r.next) {
      r.next = {
        value: item,
        next: undefined
      };
      return;
    }
    r = r.next;
  }
  const oldNext = r.next;
  r.next = {
    value: item,
    next: oldNext
  };
};
const appendItem = (node, item) => {
  let r = node.contents;
  if (r === undefined) {
    node.contents = {
      startType: true,
      next: {
        value: item,
        next: undefined
      }
    };
    return;
  }
  while (r.next !== undefined) {
    r = r.next;
  }
  r.next = {
    value: item,
    next: undefined
  };
};
const findByAddress = (mdl, address) => {
  if (address.length < 1 || mdl.contents === undefined) {
    return mdl;
  }
  const addressCopy = [...address];
  console.log(addressCopy);
  let node = findByIndex(mdl.contents, addressCopy.shift());
  while (addressCopy.length > 0) {
    if (!node || node.contents === undefined)
      return;
    const add = addressCopy.shift();
    node = findByIndex(node.contents, add);
    console.log(node);
  }
  return node;
};
const editValueAtAddress = (mdl, address, value) => {
  const node = findByAddress(mdl, address);
  if (!node)
    return;
  node.value = value;
};
const removeAtAddress = (mdl, address) => {
  const parent = address.slice(0, -1);
  const index = address[address.length - 1];
  const n = findByAddress(mdl, parent);
  console.log("removing", n, index);
  if (!n)
    return;
  removeAt(n.contents, index);
};
const addAt = (mdl, address, node) => {
  const parent = address.slice(0, -1);
  const index = address[address.length - 1];
  const n = findByAddress(mdl, parent);
  console.log("adding", index, n);
  if (!n)
    return;
  insertAt(n.contents, index, node);
};
const compareAddress = (add1, add2) => {
  const a1 = [...add1];
  const a2 = [...add2];
  while (true) {
    let a = a1.shift();
    let b = a2.shift();
    if (a === undefined) {
      return 1;
    }
    if (b === undefined) {
      return -1;
    }
    if (a === b)
      continue;
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  }
};
const onMove = (mdl, start, destination) => {
  const n = findByAddress(mdl, start);
  console.log("moving", start, destination, n);
  if (!n)
    return;
  const r = compareAddress(start, destination);
  removeAtAddress(mdl, start);
  addAt(mdl, destination, n);
};
const testModel = {
  value: undefined,
  contents: {
    startType: true,
    next: {
      value: {
        value: "First Column",
        contents: { startType: true, next: {
          value: {
            value: "First Leaf",
            contents: { startType: true, next: undefined }
          },
          next: undefined
        } }
      },
      next: {
        value: {
          value: "Second Column",
          contents: { startType: true, next: {
            value: {
              value: "Second Node",
              contents: { startType: true, next: {
                value: {
                  value: "First Inner Node",
                  contents: { startType: true, next: undefined }
                },
                next: {
                  value: {
                    value: "Second Inner Node",
                    contents: { startType: true, next: undefined }
                  },
                  next: undefined
                }
              } }
            },
            next: undefined
          } }
        },
        next: undefined
      }
    }
  }
};
let currentRoot = undefined;
let currentModel = testModel;
let update = () => {
  if (currentRoot) {
    document.body.removeChild(currentRoot);
  }
  currentRoot = buildView(currentModel);
  if (currentRoot) {
    document.body.appendChild(currentRoot);
  }
};
const createNodeElement = (node, address) => {
  const root = document.createElement("div");
  root.draggable = true;
  root.ondragstart = (ev) => {
    ev.stopPropagation();
    ev.dataTransfer?.setData("text/plain", JSON.stringify(address));
    console.log(ev.dataTransfer?.getData("text/plain"));
    const dropZones = document.getElementsByClassName("dropZone");
    for (let i = 0;i < dropZones.length; i++) {
      dropZones[i].classList.add("dropZonePotential");
    }
  };
  const message = promiseTextDisplay((node.value ?? "") + address.join("/"), (s) => {
    node.value = s;
  });
  root.appendChild(message);
  if (node.contents.next === undefined) {
    root.className = "leaf";
    return root;
  }
  root.className = "branch";
  const container = document.createElement("div");
  let i = 0;
  let n = node.contents.next;
  do {
    const child = createNodeElement(n.value, [...address, i]);
    container.append(child);
    i++;
    n = n.next;
  } while (n !== undefined);
  root.append(container);
  const addElement = (s) => {
    appendItem(node, {
      value: s,
      contents: { startType: true, next: undefined }
    });
    update();
  };
  const elementAddButton = promiseTextButton(addElement);
  root.append(elementAddButton);
  return root;
};
const createDragZone = (address) => {
  const columnDragZone = document.createElement("div");
  columnDragZone.classList.add("dropZone");
  columnDragZone.style.width = "1em";
  columnDragZone.style.outline = "1px dashed red";
  columnDragZone.ondragenter = (ev) => {
    ev.preventDefault();
    columnDragZone.classList.add("dropZoneSelected");
  };
  columnDragZone.ondragleave = (ev) => {
    ev.preventDefault();
    columnDragZone.classList.remove("dropZoneSelected");
    columnDragZone.classList.add("dropZonePotential");
  };
  columnDragZone.ondragover = (ev) => {
    ev.preventDefault();
    ev.dataTransfer.dropEffect = "move";
  };
  columnDragZone.ondrop = (ev) => {
    const d = ev.dataTransfer?.getData("text/plain");
    console.log("Trying to move!", d, address);
    if (!d)
      return;
    console.log("Should be moving1");
    const startAddress = JSON.parse(d);
    onMove(currentModel, startAddress, address);
    const dropZones = document.getElementsByClassName("dropZone");
    for (let i = 0;i < dropZones.length; i++) {
      dropZones[i].classList.remove("dropZonePotential");
      dropZones[i].classList.remove("dropZoneSelected");
    }
    update();
  };
  return columnDragZone;
};
const buildView = (model) => {
  const rootDiv = document.createElement("div");
  rootDiv.className = "root";
  const children = model.contents;
  if (children.next === undefined) {
    return;
  }
  let i = 0;
  let current = children.next;
  do {
    const columnDragZone = createDragZone([i]);
    rootDiv.append(columnDragZone);
    rootDiv.append(createNodeElement(current.value, [i]));
    current = current.next;
    i++;
  } while (current !== undefined);
  const columnDragZone = createDragZone([i]);
  rootDiv.append(columnDragZone);
  const addColumn = (s) => {
    appendItem(model, {
      value: s,
      contents: {
        startType: true,
        next: {
          value: {
            value: "Blank",
            contents: { startType: true, next: undefined }
          },
          next: undefined
        }
      }
    });
    update();
  };
  const columnAddButton = promiseTextButton(addColumn);
  rootDiv.append(columnAddButton);
  return rootDiv;
};
update();

    </script>
</html>