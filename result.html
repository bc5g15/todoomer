<html>
    <style>
        body {
            background-color: aliceblue;
            color: black;
            font-family: 'Verdana';
        }
        .leaf {
            border: 1px solid black;
            padding-inline: 0.2em;
            margin: 0.2em;
            position: relative;
        }
        .branch {
            padding: 0.2em;
            margin: 0.2em;
            border: 1px solid black;
            min-height: 5em;
            height: fit-content;
            position: relative;
        }
        .root {
            display: flex;
        }
        .dynamicText {
            margin-block-start: 1em;
            margin-block-end: 1em;
            display:block;
            word-wrap: normal;
        }
        .editableText {
            width:fit-content;
        }
        .dropZonePotential { 
            outline: 1px dashed black;
        }
        .dropZoneSelected {
            background-color: green;
        }
        .selectedNode {
            outline: 1px solid blue;
        }
        .topColumn {
            /* background-color: aqua; */
            min-width: 10em;
        }
        .controlTray {
            display: none;
            position: absolute;
            top: 0;
            right: 0; 
        }
        .selectedNode > .controlTray {
            display:flex;
        }
        .showOnSelected {
            display: none;
        }
        .selectedNode > .showOnSelected {
            display: block;
        }
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #313336;
                color: azure;
            }
            input {
                background-color: black;
                color: whitesmoke;
            }
            .dropZonePotential {
                outline: 1px dashed white;
            }
            .leaf {
                outline: 1px solid white;
            }
        }
    </style>
    <head>
        <title>Todoomer</title>
    </head>
    <body></body>
    <script>
        let editingText = false;
const promiseText = (defaultString = "") => {
  const magicForm = document.createElement("form");
  magicForm.method = "dialog";
  const textInput = document.createElement("input");
  textInput.className = "dynamicText";
  magicForm.append(textInput);
  textInput.value = defaultString;
  editingText = true;
  const p = new Promise((res) => {
    const submit = (ev) => {
      ev.preventDefault();
      editingText = false;
      const textResult = textInput.value || defaultString;
      res(textResult);
    };
    magicForm.onsubmit = submit;
    textInput.onblur = submit;
  });
  return [magicForm, p, () => {
    textInput.focus();
    textInput.select();
  }];
};
const promiseTextButton = (handleText) => {
  const btn = document.createElement("button");
  btn.textContent = "+";
  btn.onclick = async () => {
    const [form, promise, focus] = promiseText("New Node");
    btn.replaceWith(form);
    focus();
    const result = await promise;
    handleText(result);
    form.replaceWith(btn);
  };
  return btn;
};
const promiseTextDisplay = (textValue, handleText) => {
  const para = document.createElement("p");
  para.innerText = textValue;
  para.className = "editableText";
  para.onclick = async () => {
    const [form, promise, focus] = await promiseText(textValue);
    para.replaceWith(form);
    focus();
    const result = await promise;
    handleText(result);
    para.innerText = result;
    form.replaceWith(para);
  };
  return para;
};
const findByIndex = (lst, index) => {
  let r = lst.next;
  if (!r)
    return;
  while (index > 0) {
    index--;
    if (!r?.next)
      return;
    r = r.next;
  }
  return r.value;
};
const removeAt = (lst, index) => {
  let r = lst;
  while (index > 0) {
    index--;
    if (!r.next)
      return;
    r = r.next;
  }
  r.next = r.next?.next ?? undefined;
};
const insertAt = (lst, index, item) => {
  let r = lst;
  while (index > 0) {
    index--;
    if (!r.next) {
      r.next = {
        value: item,
        next: undefined
      };
      return;
    }
    r = r.next;
  }
  const oldNext = r.next;
  r.next = {
    value: item,
    next: oldNext
  };
};
const appendItem = (node, item) => {
  let r = node.contents;
  if (r === undefined) {
    node.contents = {
      startType: true,
      next: {
        value: item,
        next: undefined
      }
    };
    return;
  }
  while (r.next !== undefined) {
    r = r.next;
  }
  r.next = {
    value: item,
    next: undefined
  };
};
const findByAddress = (mdl, address) => {
  if (address.length < 1 || mdl.contents === undefined) {
    return mdl;
  }
  const addressCopy = [...address];
  let node = findByIndex(mdl.contents, addressCopy.shift());
  while (addressCopy.length > 0) {
    if (!node || node.contents === undefined)
      return;
    const add = addressCopy.shift();
    node = findByIndex(node.contents, add);
  }
  return node;
};
const removeAtAddress = (mdl, address) => {
  const parent = address.slice(0, -1);
  const index = address[address.length - 1];
  const n = findByAddress(mdl, parent);
  if (!n)
    return;
  removeAt(n.contents, index);
};
const addAt = (mdl, address, node) => {
  const parent = address.slice(0, -1);
  const index = address[address.length - 1];
  const n = findByAddress(mdl, parent);
  if (!n)
    return;
  insertAt(n.contents, index, node);
};
const compareAddress = (add1, add2) => {
  const a1 = [...add1];
  const a2 = [...add2];
  while (true) {
    let a = a1.shift();
    let b = a2.shift();
    if (a === undefined && b === undefined) {
      return 0;
    }
    if (a === undefined) {
      return 1;
    }
    if (b === undefined) {
      return -1;
    }
    if (a === b)
      continue;
    if (a < b) {
      return 1;
    }
    if (a > b) {
      return -1;
    }
    return 0;
  }
};
const isContainedBy = (start, destination) => {
  const alst = [...start];
  const blst = [...destination];
  while (true) {
    const a = alst.shift();
    const b = blst.shift();
    if (a === undefined && b === undefined) {
      return true;
    }
    if (a === b) {
      continue;
    }
    if (a === undefined) {
      return true;
    }
    return false;
  }
};
const onMove = (mdl, start, destination) => {
  const n = findByAddress(mdl, start);
  if (!n)
    return;
  const r = compareAddress(start, destination);
  if (isContainedBy(start, destination)) {
    return;
  }
  if (r === 0) {
    return;
  }
  if (r === -1) {
    removeAtAddress(mdl, start);
    addAt(mdl, destination, n);
  } else {
    addAt(mdl, destination, n);
    removeAtAddress(mdl, start);
  }
};
const MODEL_KEY = "tmdr-model";
let currentRoot = undefined;
let currentModel = JSON.parse(localStorage.getItem(MODEL_KEY) ?? JSON.stringify({
  contents: {
    startType: true,
    next: undefined
  }
}));
let update = () => {
  if (currentRoot) {
    document.body.removeChild(currentRoot);
  }
  currentRoot = buildView(currentModel);
  if (currentRoot) {
    document.body.appendChild(currentRoot);
  }
  localStorage.setItem(MODEL_KEY, JSON.stringify(currentModel));
};
const createDragZone = (address) => {
  const dragZone = document.createElement("div");
  dragZone.classList.add("dropZone");
  dragZone.ondragenter = (ev) => {
    ev.preventDefault();
    dragZone.classList.add("dropZoneSelected");
  };
  dragZone.ondragleave = (ev) => {
    ev.preventDefault();
    dragZone.classList.remove("dropZoneSelected");
    dragZone.classList.add("dropZonePotential");
  };
  dragZone.ondragover = (ev) => {
    ev.preventDefault();
    ev.dataTransfer.dropEffect = "move";
  };
  dragZone.ondrop = (ev) => {
    const d = ev.dataTransfer?.getData("text/plain");
    if (!d)
      return;
    const startAddress = JSON.parse(d);
    onMove(currentModel, startAddress, address);
    const dropZones = document.getElementsByClassName("dropZone");
    for (let i = 0;i < dropZones.length; i++) {
      dropZones[i].classList.remove("dropZonePotential");
      dropZones[i].classList.remove("dropZoneSelected");
    }
    update();
  };
  return dragZone;
};
let selectedNode = undefined;
document.body.onclick = (ev) => {
  ev.stopPropagation();
  selectedNode = undefined;
  const classes = document.getElementsByClassName("selectedNode");
  if (classes.length) {
    classes[0].classList.remove("selectedNode");
  }
};
document.onkeyup = (ev) => {
  if (!editingText && ev.code === "Delete") {
    if (selectedNode) {
      removeAtAddress(currentModel, selectedNode);
      update();
    }
  }
};
const DEFAULT_COLOUR = "#3c5375";
const DEFAULT_LEAF_COLOUR = "#000000";
const calculateTextColour = (backgroundColour) => {
  const parseHex = (startIndex, endIndex) => {
    return parseInt(backgroundColour.slice(startIndex, endIndex), 16);
  };
  const r = parseHex(1, 3);
  const g = parseHex(3, 5);
  const b = parseHex(5, 7);
  return r * 0.299 + g * 0.587 + b * 0.114 > 186 ? "#000000" : "#FFFFFF";
};
const createNodeElement = (node, address) => {
  const { text, colour } = node.value ?? {};
  const root = document.createElement("div");
  root.style.backgroundColor = colour ?? DEFAULT_COLOUR;
  root.style.color = calculateTextColour(root.style.backgroundColor);
  root.classList.add("selectableNode");
  root.draggable = true;
  root.ondragstart = (ev) => {
    ev.stopPropagation();
    ev.dataTransfer?.setData("text/plain", JSON.stringify(address));
    const dropZones = document.getElementsByClassName("dropZone");
    for (let i = 0;i < dropZones.length; i++) {
      dropZones[i].classList.add("dropZonePotential");
    }
  };
  root.ondragend = () => {
    const dropZones = document.getElementsByClassName("dropZone");
    for (let i = 0;i < dropZones.length; i++) {
      dropZones[i].classList.remove("dropZonePotential");
      dropZones[i].classList.remove("dropZoneSelected");
    }
  };
  root.onclick = (ev) => {
    ev.stopPropagation();
    const classes = document.getElementsByClassName("selectedNode");
    if (classes.length) {
      classes[0].classList.remove("selectedNode");
    }
    root.classList.add("selectedNode");
    selectedNode = address;
  };
  const controlTray = document.createElement("div");
  controlTray.classList.add("controlTray");
  root.append(controlTray);
  const delButton = document.createElement("button");
  delButton.classList.add("deleteButton");
  delButton.textContent = "X";
  delButton.onclick = () => {
    removeAtAddress(currentModel, address);
    update();
  };
  const colourButton = document.createElement("input");
  colourButton.type = "color";
  colourButton.value = colour ?? root.style.backgroundColor ?? DEFAULT_COLOUR;
  colourButton.onchange = () => {
    root.style.backgroundColor = colourButton.value;
    node.value.colour = colourButton.value;
    root.style.color = calculateTextColour(colourButton.value);
  };
  controlTray.append(colourButton);
  controlTray.append(delButton);
  const message = promiseTextDisplay(text ?? "", (s) => {
    node.value = {
      ...node.value,
      text: s
    };
    update();
  });
  root.appendChild(message);
  const addElement = (text) => {
    appendItem(node, {
      value: { text },
      contents: { startType: true, next: undefined }
    });
    update();
  };
  if (node.contents.next === undefined) {
    root.classList.add("leaf");
    if (!colour) {
      root.style.backgroundColor = DEFAULT_LEAF_COLOUR;
    }
    const dragZone = createDragZone([...address, 0]);
    dragZone.style.height = "1em";
    const leafAddButton = promiseTextButton(addElement);
    leafAddButton.classList.add("showOnSelected");
    root.append(leafAddButton);
    root.append(dragZone);
    return root;
  }
  root.classList.add("branch");
  const container = document.createElement("div");
  let i = 0;
  let n = node.contents.next;
  do {
    const dragZone = createDragZone([...address, i]);
    dragZone.style.height = "1em";
    container.append(dragZone);
    const child = createNodeElement(n.value, [...address, i]);
    container.append(child);
    i++;
    n = n.next;
  } while (n !== undefined);
  const dragZone = createDragZone([...address, i]);
  dragZone.style.height = "1em";
  container.append(dragZone);
  root.append(container);
  const elementAddButton = promiseTextButton(addElement);
  root.append(elementAddButton);
  return root;
};
const buildView = (model) => {
  const rootDiv = document.createElement("div");
  rootDiv.className = "root";
  const addColumn = (text) => {
    appendItem(model, {
      value: { text },
      contents: {
        startType: true,
        next: undefined
      }
    });
    update();
  };
  const children = model.contents;
  if (children.next === undefined) {
    const columnAddButton = promiseTextButton(addColumn);
    rootDiv.append(columnAddButton);
    return rootDiv;
  }
  let i = 0;
  let current = children.next;
  do {
    const columnDragZone = createDragZone([i]);
    columnDragZone.style.width = "1em";
    rootDiv.append(columnDragZone);
    const topColumn = createNodeElement(current.value, [i]);
    topColumn.classList.add("topColumn");
    rootDiv.append(topColumn);
    current = current.next;
    i++;
  } while (current !== undefined);
  const columnDragZone = createDragZone([i]);
  columnDragZone.style.width = "1em";
  rootDiv.append(columnDragZone);
  const columnAddButton = promiseTextButton(addColumn);
  rootDiv.append(columnAddButton);
  return rootDiv;
};
update();

    </script>
</html>