<html>
    <style>
        .leaf {
            border: 1px solid black;
            background-color: white;
            padding-inline: 1em;
        }
        .branch {
            padding: 1em;
            margin: 1em;
            border: 1px solid green;
            background-color: aqua;
            min-height: 5em;
            height: fit-content
        }
        .root {
            display: flex;
        }
        .dynamicText {
            margin-block-start: 1em;
            margin-block-end: 1em;
            display:block;
        }
        .dropZonePotential { 
            background-color: blue;
        }
        .dropZoneSelected {
            background-color: green;
        }
        .selectedNode {
            outline: 1px solid blue;
        }
    </style>
    <head>
        <title>Todoomer</title>
    </head>
    <body></body>
    <script>
        const promiseText = (defaultString = "") => {
  const magicForm = document.createElement("form");
  const textInput = document.createElement("input");
  textInput.className = "dynamicText";
  magicForm.append(textInput);
  textInput.value = defaultString;
  const p = new Promise((res) => {
    const submit = () => {
      const textResult = textInput.value;
      res(textResult);
    };
    magicForm.onsubmit = submit;
    textInput.onblur = submit;
  });
  return [magicForm, p, () => textInput.focus()];
};
const promiseTextButton = (handleText) => {
  const btn = document.createElement("button");
  btn.textContent = "+";
  btn.onclick = async () => {
    const [form, promise, focus] = promiseText();
    btn.replaceWith(form);
    focus();
    const result = await promise;
    handleText(result);
    form.replaceWith(btn);
  };
  return btn;
};
const promiseTextDisplay = (textValue, handleText) => {
  const para = document.createElement("p");
  para.innerText = textValue;
  para.className = "editableText";
  para.onclick = async () => {
    const [form, promise, focus] = await promiseText();
    para.replaceWith(form);
    focus();
    const result = await promise;
    handleText(result);
    para.innerText = result;
    form.replaceWith(para);
  };
  return para;
};
const findByIndex = (lst, index) => {
  let r = lst.next;
  if (!r)
    return;
  while (index > 0) {
    index--;
    if (!r?.next)
      return;
    r = r.next;
  }
  return r.value;
};
const removeAt = (lst, index) => {
  let r = lst;
  while (index > 0) {
    index--;
    if (!r.next)
      return;
    r = r.next;
  }
  r.next = r.next?.next ?? undefined;
};
const insertAt = (lst, index, item) => {
  let r = lst;
  while (index > 0) {
    index--;
    if (!r.next) {
      r.next = {
        value: item,
        next: undefined
      };
      return;
    }
    r = r.next;
  }
  const oldNext = r.next;
  r.next = {
    value: item,
    next: oldNext
  };
};
const appendItem = (node, item) => {
  let r = node.contents;
  if (r === undefined) {
    node.contents = {
      startType: true,
      next: {
        value: item,
        next: undefined
      }
    };
    return;
  }
  while (r.next !== undefined) {
    r = r.next;
  }
  r.next = {
    value: item,
    next: undefined
  };
};
const findByAddress = (mdl, address) => {
  if (address.length < 1 || mdl.contents === undefined) {
    return mdl;
  }
  const addressCopy = [...address];
  let node = findByIndex(mdl.contents, addressCopy.shift());
  while (addressCopy.length > 0) {
    if (!node || node.contents === undefined)
      return;
    const add = addressCopy.shift();
    node = findByIndex(node.contents, add);
  }
  return node;
};
const removeAtAddress = (mdl, address) => {
  const parent = address.slice(0, -1);
  const index = address[address.length - 1];
  const n = findByAddress(mdl, parent);
  if (!n)
    return;
  removeAt(n.contents, index);
};
const addAt = (mdl, address, node) => {
  const parent = address.slice(0, -1);
  const index = address[address.length - 1];
  const n = findByAddress(mdl, parent);
  if (!n)
    return;
  insertAt(n.contents, index, node);
};
const compareAddress = (add1, add2) => {
  const a1 = [...add1];
  const a2 = [...add2];
  console.log(a1, a2);
  while (true) {
    let a = a1.shift();
    let b = a2.shift();
    if (a === undefined && b === undefined) {
      return 0;
    }
    if (a === undefined) {
      return 1;
    }
    if (b === undefined) {
      return -1;
    }
    if (a === b)
      continue;
    if (a < b) {
      return 1;
    }
    if (a > b) {
      return -1;
    }
    return 0;
  }
};
const isContainedBy = (start, destination) => {
  const alst = [...start];
  const blst = [...destination];
  while (true) {
    const a = alst.shift();
    const b = blst.shift();
    if (a === undefined && b === undefined) {
      return true;
    }
    if (a === b) {
      continue;
    }
    if (a === undefined) {
      return true;
    }
    return false;
  }
};
const onMove = (mdl, start, destination) => {
  const n = findByAddress(mdl, start);
  if (!n)
    return;
  const r = compareAddress(start, destination);
  if (isContainedBy(start, destination)) {
    return;
  }
  console.log(r);
  if (r === 0) {
    return;
  }
  if (r === -1) {
    removeAtAddress(mdl, start);
    addAt(mdl, destination, n);
  } else {
    addAt(mdl, destination, n);
    removeAtAddress(mdl, start);
  }
};
const MODEL_KEY = "tmdr-model";
let currentRoot = undefined;
let currentModel = JSON.parse(localStorage.getItem(MODEL_KEY) ?? JSON.stringify({
  value: undefined,
  contents: {
    startType: true,
    next: undefined
  }
}));
let update = () => {
  if (currentRoot) {
    document.body.removeChild(currentRoot);
  }
  currentRoot = buildView(currentModel);
  if (currentRoot) {
    document.body.appendChild(currentRoot);
  }
  localStorage.setItem(MODEL_KEY, JSON.stringify(currentModel));
};
const createDragZone = (address) => {
  const dragZone = document.createElement("div");
  dragZone.classList.add("dropZone");
  dragZone.style.outline = "1px dashed red";
  dragZone.ondragenter = (ev) => {
    ev.preventDefault();
    dragZone.classList.add("dropZoneSelected");
  };
  dragZone.ondragend = () => {
    const dropZones = document.getElementsByClassName("dropZone");
    for (let i = 0;i < dropZones.length; i++) {
      dropZones[i].classList.remove("dropZonePotential");
      dropZones[i].classList.remove("dropZoneSelected");
    }
  };
  dragZone.ondragleave = (ev) => {
    ev.preventDefault();
    dragZone.classList.remove("dropZoneSelected");
    dragZone.classList.add("dropZonePotential");
  };
  dragZone.ondragover = (ev) => {
    ev.preventDefault();
    ev.dataTransfer.dropEffect = "move";
  };
  dragZone.ondrop = (ev) => {
    const d = ev.dataTransfer?.getData("text/plain");
    if (!d)
      return;
    const startAddress = JSON.parse(d);
    onMove(currentModel, startAddress, address);
    const dropZones = document.getElementsByClassName("dropZone");
    for (let i = 0;i < dropZones.length; i++) {
      dropZones[i].classList.remove("dropZonePotential");
      dropZones[i].classList.remove("dropZoneSelected");
    }
    update();
  };
  return dragZone;
};
let selectedNode = undefined;
document.onkeyup = (ev) => {
  if (ev.code === "Delete" || ev.code === "Backspace") {
    if (selectedNode) {
      removeAtAddress(currentModel, selectedNode);
      update();
    }
  }
};
const createNodeElement = (node, address) => {
  const root = document.createElement("div");
  root.classList.add("selectableNode");
  root.draggable = true;
  root.ondragstart = (ev) => {
    ev.stopPropagation();
    ev.dataTransfer?.setData("text/plain", JSON.stringify(address));
    const dropZones = document.getElementsByClassName("dropZone");
    for (let i = 0;i < dropZones.length; i++) {
      dropZones[i].classList.add("dropZonePotential");
    }
  };
  root.onclick = (ev) => {
    ev.stopPropagation();
    console.log(address);
    const classes = document.getElementsByClassName("selectedNode");
    if (classes.length) {
      classes[0].classList.remove("selectedNode");
    }
    root.classList.add("selectedNode");
    selectedNode = address;
  };
  const message = promiseTextDisplay((node.value ?? "") + address.join("/"), (s) => {
    node.value = s;
  });
  root.appendChild(message);
  if (node.contents.next === undefined) {
    root.classList.add("leaf");
    const dragZone = createDragZone([...address, 0]);
    dragZone.style.height = "1em";
    root.append(dragZone);
    return root;
  }
  root.classList.add("branch");
  const container = document.createElement("div");
  let i = 0;
  let n = node.contents.next;
  do {
    const dragZone = createDragZone([...address, i]);
    dragZone.style.height = "1em";
    container.append(dragZone);
    const child = createNodeElement(n.value, [...address, i]);
    container.append(child);
    i++;
    n = n.next;
  } while (n !== undefined);
  const dragZone = createDragZone([...address, i]);
  dragZone.style.height = "1em";
  container.append(dragZone);
  root.append(container);
  const addElement = (s) => {
    appendItem(node, {
      value: s,
      contents: { startType: true, next: undefined }
    });
    update();
  };
  const elementAddButton = promiseTextButton(addElement);
  root.append(elementAddButton);
  return root;
};
const buildView = (model) => {
  const rootDiv = document.createElement("div");
  rootDiv.className = "root";
  const addColumn = (s) => {
    appendItem(model, {
      value: s,
      contents: {
        startType: true,
        next: undefined
      }
    });
    update();
  };
  const children = model.contents;
  if (children.next === undefined) {
    const columnAddButton = promiseTextButton(addColumn);
    rootDiv.append(columnAddButton);
    return rootDiv;
  }
  let i = 0;
  let current = children.next;
  do {
    const columnDragZone = createDragZone([i]);
    columnDragZone.style.width = "1em";
    rootDiv.append(columnDragZone);
    rootDiv.append(createNodeElement(current.value, [i]));
    current = current.next;
    i++;
  } while (current !== undefined);
  const columnDragZone = createDragZone([i]);
  columnDragZone.style.width = "1em";
  rootDiv.append(columnDragZone);
  const columnAddButton = promiseTextButton(addColumn);
  rootDiv.append(columnAddButton);
  return rootDiv;
};
update();

    </script>
</html>